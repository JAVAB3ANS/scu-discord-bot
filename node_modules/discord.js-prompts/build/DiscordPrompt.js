"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const prompt_anything_1 = require("prompt-anything");
const events_1 = require("events");
const MessageVisual_1 = require("./visuals/MessageVisual");
const MenuVisual_1 = require("./visuals/MenuVisual");
class DiscordPrompt extends prompt_anything_1.Prompt {
    constructor() {
        super(...arguments);
        this.duration = 90000;
    }
    // Visuals
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getInactivityVisual(channel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new MessageVisual_1.MessageVisual('Menu closed due to inactivity.');
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getExitVisual(message, channel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new MessageVisual_1.MessageVisual('Menu closed.');
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getRejectVisual(error, message, channel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new MessageVisual_1.MessageVisual(error.message);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static createMenuRejection(message, data, menu) {
        return new prompt_anything_1.Rejection('That is an invalid option. Try again.');
    }
    // Override events
    onReject(error, message, channel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const visual = yield this.constructor.getRejectVisual(error, message, channel, data);
            yield this.sendVisual(visual, channel);
        });
    }
    onInactivity(channel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const visual = yield this.constructor.getInactivityVisual(channel, data);
            yield this.sendVisual(visual, channel);
        });
    }
    onExit(message, channel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const visual = yield this.constructor.getExitVisual(message, channel, data);
            yield this.sendVisual(visual, channel);
        });
    }
    createEmitter() {
        return new events_1.EventEmitter();
    }
    createCollector(channel, data) {
        const discordChannel = channel;
        const emitter = this.createEmitter();
        const collector = discordChannel.channel.createMessageCollector(m => m.author.id === data.__authorID);
        collector.on('collect', (message) => __awaiter(this, void 0, void 0, function* () {
            /**
             * This will store only user input (because of the above filter)
             * Bot messages are stored within DiscordChannel send method
             */
            channel.storeMessage(message);
            this.handleMessage(message, data, emitter);
        }));
        emitter.once('stop', () => {
            collector.stop();
        });
        return emitter;
    }
    handleMessage(message, data, emitter) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Exit
                if (message.content === 'exit') {
                    emitter.emit('exit', message);
                    return;
                }
                // Check if MenuVisual for special handling
                const visual = yield this.getVisual(data);
                if (visual instanceof MenuVisual_1.MenuVisual) {
                    this.handleMenuMessage(message, data, visual.menu, emitter);
                }
                else {
                    emitter.emit('message', message);
                }
            }
            catch (err) {
                emitter.emit('error', err);
            }
        });
    }
    handleMenuMessage(message, data, menu, emitter) {
        if (!menu.isValidSelection(message.content)) {
            const rejection = this.constructor.createMenuRejection(message, data, menu);
            emitter.emit('reject', message, rejection);
        }
        else {
            emitter.emit('message', message);
        }
    }
}
exports.DiscordPrompt = DiscordPrompt;
